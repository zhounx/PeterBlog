<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue变化侦测基本原理</title>
</head>
<script type="module">
    import Dep from './Dep.js'
    import {def, protoAugment, copyAugment} from './api.js'
</script>
<script>

    const arrayProto = Array.prototype
    // 复制一个和Array.prototype一样的对象作为拦截体，未来要用它去覆盖Array.prototype
    const arrayMethods = Object.create(arrayProto)
    const arrayMethodsList = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']
    arrayMethodsList.forEach(method => {
        // 缓存原始方法
        const original = arrayProto[method]
        Object.defineProperty(arrayMethods, method, {
            // 拦截体，我们在vue使用的函数实际是这里的函数mutator
            value: function mutator(...args) {
                //这里用来添加逻辑，添加完以后让数组调用原始方法做该做的事，比如把元素push进数组
                return original.apply(this, args)
            },
            // 不可枚举
            enumerable: false,
            configurable: true,
            writable: true
        })
    })
    const hasProto = '__proto__' in {}
    const arrayKeys = Object.getOwnPropertyNames(arrayMethods)


    class Observer {
        constructor(value) {
            this.value = value
            // 这里专门存放Array的依赖列表
            this.dep = new Dep()
            // 这里只探讨不是数组的情况，数组的数据侦测下个章节会说
            if (!Array.isArray(value)) {
                this.walk(value)
            } else {
                // value.__proto__ = arrayMethods
                const augment = hasProto ? protoAugment : copyAugment
                augment(value, arrayMethods, arrayKeys)
            }
        }

        walk(obj) {
            const keys = Object.keys(value)
            // 将传入的对象每一项都转为getter/setter形式侦测变化
            keys.forEach(key => {
                defineReactive(obj, key, obj[key])
            })
        }
    }

    function defineReactive(data, key, val) {
        if (typeof val === 'object') {
            new Observer(val)
        }
        let dep = new Dep()
        Object.defineProperty(data, key, {
            // 属性是否可枚举（for in或Object.keys等）
            enumerable: true,
            // 属性是否可配置（添加或删除）
            configurable: true,
            get() {
                // 收集该属性依赖
                dep.depend()
                return val
            },
            set(newVal) {
                if (val === newVal) {
                    return
                }
                // 在用到这个数据的地方循环触发依赖
                dep.notify()
                val = newVal
            }
        })
    }
</script>
<body>
<div></div>
</body>
</html>
